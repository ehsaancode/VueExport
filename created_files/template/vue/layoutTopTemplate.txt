<script setup>
import { ref, watch, onUnmounted, provide } from "vue";
import { useRoute } from "vue-router";
import QCustom from "../../qlib/qcustom/QCustom.vue";
import componentsMap from '../../../qlib/componentsMap.vue';

// [import_files]

const {
  QFullWidth, QRow, QDiv, QParagraph, QTextH6, QTextH5, QTextH4, QTextH3, QTextH2, QTextH1, QImage, QButton,
  QParallax, QMarquee, QStack, QIncrementCounter, QSlider, QAccordion, QAccordionItem, QAccordionBody, QWrap,
  QHorizontalParallax, QTabBar, QTab, QTabBody, QTabHeader, QFloatingButton, QDrawer, QDrawerBody, QStickyHeader,
  QHeaderBar, QForm, QFormInputElement, QInputText, QTextArea, QNSection, QMenuBar, QHMenuItem, QMenu, QSubMenu,
  QInputEmail, QInputNumber, QRadio, QCheckBox, QDropDown, QTableData, QTableWrapper, QRepeat, QTableSearch,
  QInputSearch, QIcon, QTablePagination, QTablePaginationButton, QPageIndicator, QTablePaginationInfo,
  QTablePaginationRPP, QTableSort, QTableFilter, QMap, QBottomMenu, QFlex, QVideo, QSection, QNavbar,
  QGallery, QMasonary, QProgressbarWithPercentage, QProgressbarWithStepper, QDashedProgressbar,
  QProgressbarWithSlider, QBackDrop, QCarousel, QErrorMessage, QDatePicker, QTimePicker, QDateRangePicker,
  QTable, QColumnHeaders, QColumnHeader, QTableRows, QTableRow, QTableCell, QMultiSelectDropdown, QActionFlow,
  QModalContainer, QColumnChart, QAreaChart, QLineChart, QBarChart, QPieChart
} = componentsMap;

const route = useRoute();
const openMenus = ref({});
const hoverTimeouts = ref({});
const loading = ref(false);

const props = defineProps(['setupSceneCalling', 'sceneValuePassToPage', 'receivedValueFromPage']);

// [action_variable]
// [action_method]
// [action_actions]

// Watch for route changes to clear menus
watch(
  () => route.path,
  () => {
    openMenus.value = {};
  }
);

// Cleanup timeouts on unmount
onUnmounted(() => {
  Object.values(hoverTimeouts.value).forEach(clearTimeout);
});

// Menu state management functions
const handleMouseEnter = (menuId, parentIds = []) => {
  let newMenus = { ...openMenus.value, [menuId]: true };
  
  // Ensure all parent menus remain open
  parentIds.forEach((parent) => {
    newMenus[parent] = true;
  });

  // Logic to close siblings after delay
  const timeout = setTimeout(() => {
    const freshMenus = { ...openMenus.value };
    // Close menus that are not the current one or its parents
    Object.keys(freshMenus).forEach((key) => {
      if (key !== menuId && !parentIds.includes(key)) {
         delete freshMenus[key];
      }
    });
    openMenus.value = freshMenus;
  }, 1500);
  
  openMenus.value = newMenus;
};

const handleMouseLeave = (menuId) => {
  const timeout = setTimeout(() => {
    const updatedMenus = { ...openMenus.value };
    delete updatedMenus[menuId];
    openMenus.value = updatedMenus;
  }, 1500);
  
  hoverTimeouts.value = {
    ...hoverTimeouts.value,
    [menuId]: timeout
  };
};

const handleTopMenuEnter = (menuId) => {
  openMenus.value = {};
  if (hoverTimeouts.value[menuId]) {
    clearTimeout(hoverTimeouts.value[menuId]);
  }
};

// Provide menu state/functions to descendants
provide('menuState', {
  openMenus,
  handleMouseEnter,
  handleMouseLeave,
  handleTopMenuEnter
});

[class_name]
</script>

<template>
  <QCustom>
    <div class="default-layout">